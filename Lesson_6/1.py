"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков. Проанализировать
результат и определить программы с наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде
комментариев к коду. Также укажите в комментариях версию Python
и разрядность вашей ОС.
"""

from memory_profiler import profile

"""
2. Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
# """
#
# n = int(input("вывод простых чисел до числа: "))
#
#
# @profile
# def wo_eratosfen(n):
#     lst = [2]
#     for i in range(3, n + 1, 2):
#         if i > 10 and i % 10 == 5:
#             continue
#         for j in lst:
#             if j * j - 1 > i:
#                 lst.append(i)
#                 break
#             if not i % j:
#                 break
#         else:
#             lst.append(i)
#     return lst
#
#
# @profile
# def eratosfen(n):
#     a = [i for i in range(n + 1)]
#     a[1] = 0
#
#     m = 2
#     while m < n:
#         if a[m] != 0:
#             j = m * 2
#             while j < n:
#                 a[j], j = 0, j + m
#         m += 1
#
#     return [i for i in a if i != 0]
#
#
# wo_eratosfen(n)
# eratosfen(n)


"""
Разницу в работе алгоритмов, становится заметно только при обработке больших знчений "n".

При n = 1500:
- функция "wo_eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.4 MiB
    Дополнительно выделять память не потребовалось.
  Общий размер итилизированной памяти: 13.4 MiB
  
- функция "eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.4 MiB
    Дополнительно выделено памяти: 0.100 MiB
  Общий размер итилизированной памяти: 13.5 MiB

---
При n = 9500 :
- функция "wo_eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.3 MiB
    Дополнительно выделено памяти: 0.2 MiB
  Общий размер итилизированной памяти: 13.5 MiB
  
- функция "eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.5 MiB
    Дополнительно выделено памяти: 0.3 MiB
  Общий размер итилизированной памяти: 13.8 MiB

---
При n = 100000:
- функция "wo_eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.4 MiB
    Дополнительно выделено памяти: 0.5 MiB
  Общий размер итилизированной памяти: 13.9 MiB
  
- функция "eratosfen(n)":
    Первоначальный объём выделенной памяти: 13.6 MiB
    Дополнительно выделено памяти: 3.8 MiB
  Общий размер итилизированной памяти: 17.4 MiB
---

Общий вывод:
При значениях n < 1500 оба алгоритма потребляют одинаковое количество памяти. 

При превышении данного порога алгоритм функции "eratosfen(n)" начинает потреблять дополнительную память, тогда как 
алгоритм функции "wo_eratosfen(n)" по прежнему укладывается в первоначально выделенный объём памяти.

При превышении порога значениея n в 9500 алгоритм функции "wo_eratosfen(n)" так же начинает потреблять дополнительную
память, но в горадздо меньших количествах, нежели алгоритм функции "eratosfen(n)".

Таким образом можно сделать вывод, что алгоритм функции "eratosfen(n)" является наиболее эффективным с 
точки зрения потребления памяти.
"""

"""
# 4.	Определить, какое число в массиве встречается чаще всего.
"""
# # Вариант 1
# @profile
# def v1(a):
#     f = None
#     f_max = 0
#
#     for i in a:
#         ic = a.count(i)
#         if ic > f_max:
#             f_max = ic
#             f = i
#
#     print(f"Число {f} встречается чаще всего ({f_max} раз(а))")
#
#
# # Вариант 2
# @profile
# def v2(a):
#     f = a[0]
#     f_max = 1
#     arr_len = len(a)
#     for i in range(arr_len - 1):
#         frq = 1
#         for j in range(i + 1, arr_len):
#             if a[i] == a[j]:
#                 frq += 1
#         if frq > f_max:
#             f_max = frq
#             f = a[i]
#
#     print(f"Число {f} встречается чаще всего ({f_max} раз(а))")
#
# from random import randint
#
# for i in range(1, 4):
#     a = [randint(1, 5) for _ in range(3*10**i)]
#     print(f"****** \n a = {a}\n len = {len(a)}\n******")
#     v1(a)
#     v2(a)
"""
Исследование проводилось на случайно сгернерированных массивах значений, длинною 30, 300 и 3000 значений.
Для обработки всех наборов значений первоначально было выделено 15.4 MiB памяти. 

По результатам исследования видно что независимо от размера передаваемых исходных данных, оба алгоритма не
требует дополнительного выделения памяти.

Из чего следует вывод, что оба алгоритма являются оптимальными (относительно друг друга) в части использования памяти.
"""

"""
6.	В одномерном массиве найти сумму элементов, находящихся
между минимальным и максимальным элементами.
Сами минимальный и максимальный элементы в сумму не включать.
"""
# from random import randint
#
#
# #  Варинт 1
# @profile
# def v1(a):
#     s1 = 0
#     for i in range(min_i + 1, max_i):
#         s1 += a[i]
#     print(f"Вариант 1: Сумма = {s1}")
#
#
# # Вариант 2
# @profile
# def v2(a):
#     s2 = sum(a[min_i + 1:max_i])
#     print(f"Вариант 2: Сумма = {s2}")
#
#
# for i in range(1, 4):
#     array_len = 6 * 100**i
#     a = [randint(0, 100) for _ in range(array_len)]
#     max_v, min_v, min_i, max_i = a[0], a[0], 0, 0
#
#     for i in range(len(a)):
#         if a[i] > max_v:
#             max_i = i
#             max_v = a[i]
#         elif a[i] < min_v:
#             min_i = i
#             min_v = a[i]
#
#     if min_i > max_i:
#         min_i, max_i = max_i, min_i
#
#     print(f"Исходный массив: length = {len(a)}\n\n")
#     v1(a)
#     v2(a)
"""
Исследование проводилось на случайно сгернерированных массивах значений, длинною 600, 60000 и 6000000 значений.

В процессе работы обоих алгоритмов объём первонячально выделенной памяти был одинаков и выделение дополнительной памяти 
не потребовалось. Размер используемой памяти увеличивался в зависимости от объёма обрабатываемых данных, 
т.е. чем больше данных обрабатываем, тем больше памяти выделяется. 

Например:
- для 600 значений, потребовалось 15.5 MiB
- для 60000 значений, потребовалось 16.3 MiB
- для 6000000 значений, потребовалось 61.7 MiB

Из этого можно сделать вывод, что оба алгоритма являются оптимальными (относительно друг друга) в части использования 
памяти.
"""